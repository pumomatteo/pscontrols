{"version":3,"file":"qrCodeManager.js","sources":["../../../src/managers/qrCodeManager.ts"],"sourcesContent":["type bit = number;\ntype byte = number;\ntype int = number;\n\nexport class QrCodeManager\n{\n\t// Returns a QR Code representing the given Unicode text string at the given error correction level.\n\tpublic static encodeText(text: string, ecl: Ecc): QrCodeManager\n\t{\n\t\tconst segs: Array<QrSegment> = QrSegment.makeSegments(text);\n\t\treturn QrCodeManager.encodeSegments(segs, ecl);\n\t}\n\n\t// Returns a QR Code representing the given binary data at the given error correction level.\n\tpublic static encodeBinary(data: Array<byte>, ecl: Ecc): QrCodeManager\n\t{\n\t\tconst seg: QrSegment = QrSegment.makeBytes(data);\n\t\treturn QrCodeManager.encodeSegments([seg], ecl);\n\t}\n\n\t// Returns a QR Code representing the given segments with the given encoding parameters.\n\tpublic static encodeSegments(segs: Array<QrSegment>, ecl: Ecc,\n\t\tminVersion: int = 1, maxVersion: int = 40,\n\t\tmask: int = -1, boostEcl: boolean = true): QrCodeManager\n\t{\n\t\tif (!(QrCodeManager.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCodeManager.MAX_VERSION)\n\t\t\t|| mask < -1 || mask > 7)\n\t\t\tthrow \"Invalid value\";\n\n\t\t// Find the minimal version number to use\n\t\tlet version: int;\n\t\tlet dataUsedBits: int;\n\t\tfor (version = minVersion; ; version++)\n\t\t{\n\t\t\tconst dataCapacityBits: int = QrCodeManager.getNumDataCodewords(version, ecl) * 8;  // Number of data bits available\n\t\t\tconst usedBits: number = QrSegment.getTotalBits(segs, version);\n\t\t\tif (usedBits <= dataCapacityBits)\n\t\t\t{\n\t\t\t\tdataUsedBits = usedBits;\n\t\t\t\tbreak;  // This version number is found to be suitable\n\t\t\t}\n\t\t\tif (version >= maxVersion)  // All versions in the range could not fit the given data\n\t\t\t\tthrow \"Data too long\";\n\t\t}\n\n\t\t// Increase the error correction level while the data still fits in the current version number\n\t\tfor (const newEcl of [Ecc.MEDIUM, Ecc.QUARTILE, Ecc.HIGH])\n\t\t{  // From low to high\n\t\t\tif (boostEcl && dataUsedBits <= QrCodeManager.getNumDataCodewords(version, newEcl) * 8)\n\t\t\t\tecl = newEcl;\n\t\t}\n\n\t\t// Concatenate all segments to create the data bit string\n\t\tlet bb: Array<bit> = []\n\t\tfor (const seg of segs)\n\t\t{\n\t\t\tappendBits(seg.mode.modeBits, 4, bb);\n\t\t\tappendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n\t\t\tfor (const b of seg.getData())\n\t\t\t\tbb.push(b);\n\t\t}\n\t\tif (bb.length != dataUsedBits)\n\t\t\tthrow \"Assertion error\";\n\n\t\t// Add terminator and pad up to a byte if applicable\n\t\tconst dataCapacityBits: int = QrCodeManager.getNumDataCodewords(version, ecl) * 8;\n\t\tif (bb.length > dataCapacityBits)\n\t\t\tthrow \"Assertion error\";\n\t\tappendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n\t\tappendBits(0, (8 - bb.length % 8) % 8, bb);\n\t\tif (bb.length % 8 != 0)\n\t\t\tthrow \"Assertion error\";\n\n\t\t// Pad with alternating bytes until data capacity is reached\n\t\tfor (let padByte = 0xEC; bb.length < dataCapacityBits; padByte ^= 0xEC ^ 0x11)\n\t\t\tappendBits(padByte, 8, bb);\n\n\t\t// Pack bits into bytes in big endian\n\t\tlet dataCodewords: Array<byte> = [];\n\t\twhile (dataCodewords.length * 8 < bb.length)\n\t\t\tdataCodewords.push(0);\n\t\tbb.forEach((b: bit, i: int) =>\n\t\t\tdataCodewords[i >>> 3] |= b << (7 - (i & 7)));\n\n\t\t// Create the QR Code object\n\t\treturn new QrCodeManager(version, ecl, dataCodewords, mask);\n\t}\n\n\t// The width and height of this QR Code, measured in modules, between\n\t// 21 and 177 (inclusive). This is equal to version * 4 + 17.\n\tpublic readonly size: int;\n\n\t// The modules of this QR Code (false = white, true = black).\n\t// Immutable after constructor finishes. Accessed through getModule().\n\tprivate readonly modules: Array<Array<boolean>> = [];\n\n\t// Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n\tprivate readonly isFunction: Array<Array<boolean>> = [];\n\n\n\t/*-- Constructor (low level) and fields --*/\n\n\t// Creates a new QR Code with the given version number,\n\t// error correction level, data codeword bytes, and mask number.\n\t// This is a low-level API that most users should not use directly.\n\t// A mid-level API is the encodeSegments() function.\n\tpublic constructor(\n\t\t// The version number of this QR Code, which is between 1 and 40 (inclusive).\n\t\t// This determines the size of this barcode.\n\t\tpublic readonly version: int,\n\n\t\t// The error correction level used in this QR Code.\n\t\tpublic readonly errorCorrectionLevel: Ecc,\n\n\t\tdataCodewords: Array<byte>,\n\n\t\t// The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n\t\t// Even if a QR Code is created with automatic masking requested (mask = -1),\n\t\t// the resulting object still has a mask value between 0 and 7.\n\t\tpublic readonly mask: int)\n\t{\n\n\t\t// Check scalar arguments\n\t\tif (version < QrCodeManager.MIN_VERSION || version > QrCodeManager.MAX_VERSION)\n\t\t\tthrow \"Version value out of range\";\n\t\tif (mask < -1 || mask > 7)\n\t\t\tthrow \"Mask value out of range\";\n\t\tthis.size = version * 4 + 17;\n\n\t\t// Initialize both grids to be size*size arrays of Boolean false\n\t\tlet row: Array<boolean> = [];\n\t\tfor (let i = 0; i < this.size; i++)\n\t\t\trow.push(false);\n\t\tfor (let i = 0; i < this.size; i++)\n\t\t{\n\t\t\tthis.modules.push(row.slice());  // Initially all white\n\t\t\tthis.isFunction.push(row.slice());\n\t\t}\n\n\t\t// Compute ECC, draw modules\n\t\tthis.drawFunctionPatterns();\n\t\tconst allCodewords: Array<byte> = this.addEccAndInterleave(dataCodewords);\n\t\tthis.drawCodewords(allCodewords);\n\n\t\t// Do masking\n\t\tif (mask == -1)\n\t\t{  // Automatically choose best mask\n\t\t\tlet minPenalty: int = 1000000000;\n\t\t\tfor (let i = 0; i < 8; i++)\n\t\t\t{\n\t\t\t\tthis.applyMask(i);\n\t\t\t\tthis.drawFormatBits(i);\n\t\t\t\tconst penalty: int = this.getPenaltyScore();\n\t\t\t\tif (penalty < minPenalty)\n\t\t\t\t{\n\t\t\t\t\tmask = i;\n\t\t\t\t\tminPenalty = penalty;\n\t\t\t\t}\n\t\t\t\tthis.applyMask(i);  // Undoes the mask due to XOR\n\t\t\t}\n\t\t}\n\t\tif (mask < 0 || mask > 7)\n\t\t\tthrow \"Assertion error\";\n\t\tthis.mask = mask;\n\t\tthis.applyMask(mask);  // Apply the final choice of mask\n\t\tthis.drawFormatBits(mask);  // Overwrite old format bits\n\n\t\tthis.isFunction = [];\n\t}\n\n\n\t/*-- Accessor methods --*/\n\n\t// Returns the color of the module (pixel) at the given coordinates, which is false\n\t// for white or true for black. The top left corner has the coordinates (x=0, y=0).\n\t// If the given coordinates are out of bounds, then false (white) is returned.\n\tpublic getModule(x: int, y: int): boolean\n\t{\n\t\treturn 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n\t}\n\n\n\t/*-- Public instance methods --*/\n\n\t// Draws this QR Code, with the given module scale and border modules, onto the given HTML\n\t// canvas element. The canvas's width and height is resized to (this.size + border * 2) * scale.\n\t// The drawn image is be purely black and white, and fully opaque.\n\t// The scale must be a positive integer and the border must be a non-negative integer.\n\tpublic drawCanvas(scale: int, border: int, canvas: HTMLCanvasElement): void\n\t{\n\t\tif (scale <= 0 || border < 0)\n\t\t\tthrow \"Value out of range\";\n\t\tconst width: int = (this.size + border * 2) * scale;\n\t\tcanvas.width = width;\n\t\tcanvas.height = width;\n\t\tlet ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\t\tfor (let y = -border; y < this.size + border; y++)\n\t\t{\n\t\t\tfor (let x = -border; x < this.size + border; x++)\n\t\t\t{\n\t\t\t\tctx.fillStyle = this.getModule(x, y) ? \"#000000\" : \"#FFFFFF\";\n\t\t\t\tctx.fillRect((x + border) * scale, (y + border) * scale, scale, scale);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Returns a string of SVG code for an image depicting this QR Code, with the given number\n\t// of border modules. The string always uses Unix newlines (\\n), regardless of the platform.\n\tpublic toSvgString(border: int, color: string): string\n\t{\n\t\tif (border < 0)\n\t\t\tthrow \"Border must be non-negative\";\n\t\tlet parts: Array<string> = [];\n\t\tfor (let y = 0; y < this.size; y++)\n\t\t{\n\t\t\tfor (let x = 0; x < this.size; x++)\n\t\t\t{\n\t\t\t\tif (this.getModule(x, y))\n\t\t\t\t\tparts.push(`M${x + border},${y + border}h1v1h-1z`);\n\t\t\t}\n\t\t}\n\t\treturn `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ${this.size + border * 2} ${this.size + border * 2}\" stroke=\"none\">\n\t<rect width=\"100%\" height=\"100%\" fill=\"#FFFFFF\"/>\n\t<path d=\"${parts.join(\" \")}\" fill=\"` + color + `\"/>\n</svg>\n`\n\t}\n\n\t// Reads this object's version field, and draws and marks all function modules.\n\tprivate drawFunctionPatterns(): void\n\t{\n\t\t// Draw horizontal and vertical timing patterns\n\t\tfor (let i = 0; i < this.size; i++)\n\t\t{\n\t\t\tthis.setFunctionModule(6, i, i % 2 == 0);\n\t\t\tthis.setFunctionModule(i, 6, i % 2 == 0);\n\t\t}\n\n\t\t// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n\t\tthis.drawFinderPattern(3, 3);\n\t\tthis.drawFinderPattern(this.size - 4, 3);\n\t\tthis.drawFinderPattern(3, this.size - 4);\n\n\t\t// Draw numerous alignment patterns\n\t\tconst alignPatPos: Array<int> = this.getAlignmentPatternPositions();\n\t\tconst numAlign: int = alignPatPos.length;\n\t\tfor (let i = 0; i < numAlign; i++)\n\t\t{\n\t\t\tfor (let j = 0; j < numAlign; j++)\n\t\t\t{\n\t\t\t\t// Don't draw on the three finder corners\n\t\t\t\tif (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))\n\t\t\t\t\tthis.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n\t\t\t}\n\t\t}\n\n\t\t// Draw configuration data\n\t\tthis.drawFormatBits(0);  // Dummy mask value; overwritten later in the constructor\n\t\tthis.drawVersion();\n\t}\n\n\t// Draws two copies of the format bits (with its own error correction code)\n\t// based on the given mask and this object's error correction level field.\n\tprivate drawFormatBits(mask: int): void\n\t{\n\t\t// Calculate error correction code and pack bits\n\t\tconst data: int = this.errorCorrectionLevel.formatBits << 3 | mask;  // errCorrLvl is uint2, mask is uint3\n\t\tlet rem: int = data;\n\t\tfor (let i = 0; i < 10; i++)\n\t\t\trem = (rem << 1) ^ ((rem >>> 9) * 0x537);\n\t\tconst bits = (data << 10 | rem) ^ 0x5412;  // uint15\n\t\tif (bits >>> 15 != 0)\n\t\t\tthrow \"Assertion error\";\n\n\t\t// Draw first copy\n\t\tfor (let i = 0; i <= 5; i++)\n\t\t\tthis.setFunctionModule(8, i, getBit(bits, i));\n\t\tthis.setFunctionModule(8, 7, getBit(bits, 6));\n\t\tthis.setFunctionModule(8, 8, getBit(bits, 7));\n\t\tthis.setFunctionModule(7, 8, getBit(bits, 8));\n\t\tfor (let i = 9; i < 15; i++)\n\t\t\tthis.setFunctionModule(14 - i, 8, getBit(bits, i));\n\n\t\t// Draw second copy\n\t\tfor (let i = 0; i < 8; i++)\n\t\t\tthis.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n\t\tfor (let i = 8; i < 15; i++)\n\t\t\tthis.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n\t\tthis.setFunctionModule(8, this.size - 8, true);  // Always black\n\t}\n\n\t// Draws two copies of the version bits (with its own error correction code),\n\t// based on this object's version field, iff 7 <= version <= 40.\n\tprivate drawVersion(): void\n\t{\n\t\tif (this.version < 7)\n\t\t\treturn;\n\n\t\t// Calculate error correction code and pack bits\n\t\tlet rem: int = this.version;  // version is uint6, in the range [7, 40]\n\t\tfor (let i = 0; i < 12; i++)\n\t\t\trem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);\n\t\tconst bits: int = this.version << 12 | rem;  // uint18\n\t\tif (bits >>> 18 != 0)\n\t\t\tthrow \"Assertion error\";\n\n\t\t// Draw two copies\n\t\tfor (let i = 0; i < 18; i++)\n\t\t{\n\t\t\tconst color: boolean = getBit(bits, i);\n\t\t\tconst a: int = this.size - 11 + i % 3;\n\t\t\tconst b: int = Math.floor(i / 3);\n\t\t\tthis.setFunctionModule(a, b, color);\n\t\t\tthis.setFunctionModule(b, a, color);\n\t\t}\n\t}\n\n\t// Draws a 9*9 finder pattern including the border separator,\n\t// with the center module at (x, y). Modules can be out of bounds.\n\tprivate drawFinderPattern(x: int, y: int): void\n\t{\n\t\tfor (let dy = -4; dy <= 4; dy++)\n\t\t{\n\t\t\tfor (let dx = -4; dx <= 4; dx++)\n\t\t\t{\n\t\t\t\tconst dist: int = Math.max(Math.abs(dx), Math.abs(dy));  // Chebyshev/infinity norm\n\t\t\t\tconst xx: int = x + dx;\n\t\t\t\tconst yy: int = y + dy;\n\t\t\t\tif (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)\n\t\t\t\t\tthis.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Draws a 5*5 alignment pattern, with the center module\n\t// at (x, y). All modules must be in bounds.\n\tprivate drawAlignmentPattern(x: int, y: int): void\n\t{\n\t\tfor (let dy = -2; dy <= 2; dy++)\n\t\t{\n\t\t\tfor (let dx = -2; dx <= 2; dx++)\n\t\t\t\tthis.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n\t\t}\n\t}\n\n\t// Sets the color of a module and marks it as a function module.\n\t// Only used by the constructor. Coordinates must be in bounds.\n\tprivate setFunctionModule(x: int, y: int, isBlack: boolean): void\n\t{\n\t\tthis.modules[y][x] = isBlack;\n\t\tthis.isFunction[y][x] = true;\n\t}\n\n\t// Returns a new byte string representing the given data with the appropriate error correction\n\t// codewords appended to it, based on this object's version and error correction level.\n\tprivate addEccAndInterleave(data: Array<byte>): Array<byte>\n\t{\n\t\tconst ver: int = this.version;\n\t\tconst ecl: Ecc = this.errorCorrectionLevel;\n\t\tif (data.length != QrCodeManager.getNumDataCodewords(ver, ecl))\n\t\t\tthrow \"Invalid argument\";\n\n\t\t// Calculate parameter numbers\n\t\tconst numBlocks: int = QrCodeManager.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n\t\tconst blockEccLen: int = QrCodeManager.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n\t\tconst rawCodewords: int = Math.floor(QrCodeManager.getNumRawDataModules(ver) / 8);\n\t\tconst numShortBlocks: int = numBlocks - rawCodewords % numBlocks;\n\t\tconst shortBlockLen: int = Math.floor(rawCodewords / numBlocks);\n\n\t\t// Split data into blocks and append ECC to each block\n\t\tlet blocks: Array<Array<byte>> = [];\n\t\tconst rsDiv: Array<byte> = QrCodeManager.reedSolomonComputeDivisor(blockEccLen);\n\t\tfor (let i = 0, k = 0; i < numBlocks; i++)\n\t\t{\n\t\t\tlet dat: Array<byte> = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n\t\t\tk += dat.length;\n\t\t\tconst ecc: Array<byte> = QrCodeManager.reedSolomonComputeRemainder(dat, rsDiv);\n\t\t\tif (i < numShortBlocks)\n\t\t\t\tdat.push(0);\n\t\t\tblocks.push(dat.concat(ecc));\n\t\t}\n\n\t\t// Interleave (not concatenate) the bytes from every block into a single sequence\n\t\tlet result: Array<byte> = [];\n\t\tfor (let i = 0; i < blocks[0].length; i++)\n\t\t{\n\t\t\tblocks.forEach((block, j) =>\n\t\t\t{\n\t\t\t\t// Skip the padding byte in short blocks\n\t\t\t\tif (i != shortBlockLen - blockEccLen || j >= numShortBlocks)\n\t\t\t\t\tresult.push(block[i]);\n\t\t\t});\n\t\t}\n\t\tif (result.length != rawCodewords)\n\t\t\tthrow \"Assertion error\";\n\t\treturn result;\n\t}\n\n\t// Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n\t// data area of this QR Code. Function modules need to be marked off before this is called.\n\tprivate drawCodewords(data: Array<byte>): void\n\t{\n\t\tif (data.length != Math.floor(QrCodeManager.getNumRawDataModules(this.version) / 8))\n\t\t\tthrow \"Invalid argument\";\n\t\tlet i: int = 0;  // Bit index into the data\n\t\t// Do the funny zigzag scan\n\t\tfor (let right = this.size - 1; right >= 1; right -= 2)\n\t\t{  // Index of right column in each column pair\n\t\t\tif (right == 6)\n\t\t\t\tright = 5;\n\t\t\tfor (let vert = 0; vert < this.size; vert++)\n\t\t\t{  // Vertical counter\n\t\t\t\tfor (let j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tconst x: int = right - j;  // Actual x coordinate\n\t\t\t\t\tconst upward: boolean = ((right + 1) & 2) == 0;\n\t\t\t\t\tconst y: int = upward ? this.size - 1 - vert : vert;  // Actual y coordinate\n\t\t\t\t\tif (!this.isFunction[y][x] && i < data.length * 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\t// If this QR Code has any remainder bits (0 to 7), they were assigned as\n\t\t\t\t\t// 0/false/white by the constructor and are left unchanged by this method\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i != data.length * 8)\n\t\t\tthrow \"Assertion error\";\n\t}\n\n\t// XORs the codeword modules in this QR Code with the given mask pattern.\n\t// The function modules must be marked and the codeword bits must be drawn\n\t// before masking. Due to the arithmetic of XOR, calling applyMask() with\n\t// the same mask value a second time will undo the mask. A final well-formed\n\t// QR Code needs exactly one (not zero, two, etc.) mask applied.\n\tprivate applyMask(mask: int): void\n\t{\n\t\tif (mask < 0 || mask > 7)\n\t\t\tthrow \"Mask value out of range\";\n\t\tfor (let y = 0; y < this.size; y++)\n\t\t{\n\t\t\tfor (let x = 0; x < this.size; x++)\n\t\t\t{\n\t\t\t\tlet invert: boolean;\n\t\t\t\tswitch (mask)\n\t\t\t\t{\n\t\t\t\t\tcase 0: invert = (x + y) % 2 == 0; break;\n\t\t\t\t\tcase 1: invert = y % 2 == 0; break;\n\t\t\t\t\tcase 2: invert = x % 3 == 0; break;\n\t\t\t\t\tcase 3: invert = (x + y) % 3 == 0; break;\n\t\t\t\t\tcase 4: invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0; break;\n\t\t\t\t\tcase 5: invert = x * y % 2 + x * y % 3 == 0; break;\n\t\t\t\t\tcase 6: invert = (x * y % 2 + x * y % 3) % 2 == 0; break;\n\t\t\t\t\tcase 7: invert = ((x + y) % 2 + x * y % 3) % 2 == 0; break;\n\t\t\t\t\tdefault: throw \"Assertion error\";\n\t\t\t\t}\n\t\t\t\tif (!this.isFunction[y][x] && invert)\n\t\t\t\t\tthis.modules[y][x] = !this.modules[y][x];\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculates and returns the penalty score based on state of this QR Code's current modules.\n\t// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n\tprivate getPenaltyScore(): int\n\t{\n\t\tlet result: int = 0;\n\n\t\t// Adjacent modules in row having same color, and finder-like patterns\n\t\tfor (let y = 0; y < this.size; y++)\n\t\t{\n\t\t\tlet runColor = false;\n\t\t\tlet runX = 0;\n\t\t\tlet runHistory = [0, 0, 0, 0, 0, 0, 0];\n\t\t\tfor (let x = 0; x < this.size; x++)\n\t\t\t{\n\t\t\t\tif (this.modules[y][x] == runColor)\n\t\t\t\t{\n\t\t\t\t\trunX++;\n\t\t\t\t\tif (runX == 5)\n\t\t\t\t\t\tresult += QrCodeManager.PENALTY_N1;\n\t\t\t\t\telse if (runX > 5)\n\t\t\t\t\t\tresult++;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tthis.finderPenaltyAddHistory(runX, runHistory);\n\t\t\t\t\tif (!runColor)\n\t\t\t\t\t\tresult += this.finderPenaltyCountPatterns(runHistory) * QrCodeManager.PENALTY_N3;\n\t\t\t\t\trunColor = this.modules[y][x];\n\t\t\t\t\trunX = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCodeManager.PENALTY_N3;\n\t\t}\n\t\t// Adjacent modules in column having same color, and finder-like patterns\n\t\tfor (let x = 0; x < this.size; x++)\n\t\t{\n\t\t\tlet runColor = false;\n\t\t\tlet runY = 0;\n\t\t\tlet runHistory = [0, 0, 0, 0, 0, 0, 0];\n\t\t\tfor (let y = 0; y < this.size; y++)\n\t\t\t{\n\t\t\t\tif (this.modules[y][x] == runColor)\n\t\t\t\t{\n\t\t\t\t\trunY++;\n\t\t\t\t\tif (runY == 5)\n\t\t\t\t\t\tresult += QrCodeManager.PENALTY_N1;\n\t\t\t\t\telse if (runY > 5)\n\t\t\t\t\t\tresult++;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tthis.finderPenaltyAddHistory(runY, runHistory);\n\t\t\t\t\tif (!runColor)\n\t\t\t\t\t\tresult += this.finderPenaltyCountPatterns(runHistory) * QrCodeManager.PENALTY_N3;\n\t\t\t\t\trunColor = this.modules[y][x];\n\t\t\t\t\trunY = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * QrCodeManager.PENALTY_N3;\n\t\t}\n\n\t\t// 2*2 blocks of modules having same color\n\t\tfor (let y = 0; y < this.size - 1; y++)\n\t\t{\n\t\t\tfor (let x = 0; x < this.size - 1; x++)\n\t\t\t{\n\t\t\t\tconst color: boolean = this.modules[y][x];\n\t\t\t\tif (color == this.modules[y][x + 1] &&\n\t\t\t\t\tcolor == this.modules[y + 1][x] &&\n\t\t\t\t\tcolor == this.modules[y + 1][x + 1])\n\t\t\t\t\tresult += QrCodeManager.PENALTY_N2;\n\t\t\t}\n\t\t}\n\n\t\t// Balance of black and white modules\n\t\tlet black: int = 0;\n\t\tfor (const row of this.modules)\n\t\t\tblack = row.reduce((sum, color) => sum + (color ? 1 : 0), black);\n\t\tconst total: int = this.size * this.size;  // Note that size is odd, so black/total != 1/2\n\t\t// Compute the smallest integer k >= 0 such that (45-5k)% <= black/total <= (55+5k)%\n\t\tconst k: int = Math.ceil(Math.abs(black * 20 - total * 10) / total) - 1;\n\t\tresult += k * QrCodeManager.PENALTY_N4;\n\t\treturn result;\n\t}\n\n\t// Returns an ascending list of positions of alignment patterns for this version number.\n\t// Each position is in the range [0,177), and are used on both the x and y axes.\n\t// This could be implemented as lookup table of 40 variable-length lists of integers.\n\tprivate getAlignmentPatternPositions(): Array<int>\n\t{\n\t\tif (this.version == 1)\n\t\t\treturn [];\n\t\telse\n\t\t{\n\t\t\tconst numAlign: int = Math.floor(this.version / 7) + 2;\n\t\t\tconst step: int = (this.version == 32) ? 26 :\n\t\t\t\tMath.ceil((this.size - 13) / (numAlign * 2 - 2)) * 2;\n\t\t\tlet result: Array<int> = [6];\n\t\t\tfor (let pos = this.size - 7; result.length < numAlign; pos -= step)\n\t\t\t\tresult.splice(1, 0, pos);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Returns the number of data bits that can be stored in a QR Code of the given version number, after\n\t// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n\t// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n\tprivate static getNumRawDataModules(ver: int): int\n\t{\n\t\tif (ver < QrCodeManager.MIN_VERSION || ver > QrCodeManager.MAX_VERSION)\n\t\t\tthrow \"Version number out of range\";\n\t\tlet result: int = (16 * ver + 128) * ver + 64;\n\t\tif (ver >= 2)\n\t\t{\n\t\t\tconst numAlign: int = Math.floor(ver / 7) + 2;\n\t\t\tresult -= (25 * numAlign - 10) * numAlign - 55;\n\t\t\tif (ver >= 7)\n\t\t\t\tresult -= 36;\n\t\t}\n\t\tif (!(208 <= result && result <= 29648))\n\t\t\tthrow \"Assertion error\";\n\t\treturn result;\n\t}\n\n\t// Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n\t// QR Code of the given version number and error correction level, with remainder bits discarded.\n\t// This stateless pure function could be implemented as a (40*4)-cell lookup table.\n\tprivate static getNumDataCodewords(ver: int, ecl: Ecc): int\n\t{\n\t\treturn Math.floor(QrCodeManager.getNumRawDataModules(ver) / 8) -\n\t\t\tQrCodeManager.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] *\n\t\t\tQrCodeManager.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n\t}\n\n\t// Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n\t// implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n\tprivate static reedSolomonComputeDivisor(degree: int): Array<byte>\n\t{\n\t\tif (degree < 1 || degree > 255)\n\t\t\tthrow \"Degree out of range\";\n\t\t// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n\t\t// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].\n\t\tlet result: Array<byte> = [];\n\t\tfor (let i = 0; i < degree - 1; i++)\n\t\t\tresult.push(0);\n\t\tresult.push(1);  // Start off with the monomial x^0\n\n\t\t// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n\t\t// and drop the highest monomial term which is always 1x^degree.\n\t\t// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n\t\tlet root = 1;\n\t\tfor (let i = 0; i < degree; i++)\n\t\t{\n\t\t\t// Multiply the current product by (x - r^i)\n\t\t\tfor (let j = 0; j < result.length; j++)\n\t\t\t{\n\t\t\t\tresult[j] = QrCodeManager.reedSolomonMultiply(result[j], root);\n\t\t\t\tif (j + 1 < result.length)\n\t\t\t\t\tresult[j] ^= result[j + 1];\n\t\t\t}\n\t\t\troot = QrCodeManager.reedSolomonMultiply(root, 0x02);\n\t\t}\n\t\treturn result;\n\t}\n\n\t// Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n\tprivate static reedSolomonComputeRemainder(data: Array<byte>, divisor: Array<byte>): Array<byte>\n\t{\n\t\tlet result: Array<byte> = divisor.map(_ => 0);\n\t\tfor (const b of data)\n\t\t{  // Polynomial division\n\t\t\tconst factor: byte = b ^ (result.shift() as byte);\n\t\t\tresult.push(0);\n\t\t\tdivisor.forEach((coef, i) =>\n\t\t\t\tresult[i] ^= QrCodeManager.reedSolomonMultiply(coef, factor));\n\t\t}\n\t\treturn result;\n\t}\n\n\t// Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n\t// are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.\n\tprivate static reedSolomonMultiply(x: byte, y: byte): byte\n\t{\n\t\tif (x >>> 8 != 0 || y >>> 8 != 0)\n\t\t\tthrow \"Byte out of range\";\n\t\t// Russian peasant multiplication\n\t\tlet z: int = 0;\n\t\tfor (let i = 7; i >= 0; i--)\n\t\t{\n\t\t\tz = (z << 1) ^ ((z >>> 7) * 0x11D);\n\t\t\tz ^= ((y >>> i) & 1) * x;\n\t\t}\n\t\tif (z >>> 8 != 0)\n\t\t\tthrow \"Assertion error\";\n\t\treturn z as byte;\n\t}\n\n\t// Can only be called immediately after a white run is added, and\n\t// returns either 0, 1, or 2. A helper function for getPenaltyScore().\n\tprivate finderPenaltyCountPatterns(runHistory: Array<int>): int\n\t{\n\t\tconst n: int = runHistory[1];\n\t\tif (n > this.size * 3)\n\t\t\tthrow \"Assertion error\";\n\t\tconst core: boolean = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n\t\treturn (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0)\n\t\t\t+ (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n\t}\n\n\t// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n\tprivate finderPenaltyTerminateAndCount(currentRunColor: boolean, currentRunLength: int, runHistory: Array<int>): int\n\t{\n\t\tif (currentRunColor)\n\t\t{  // Terminate black run\n\t\t\tthis.finderPenaltyAddHistory(currentRunLength, runHistory);\n\t\t\tcurrentRunLength = 0;\n\t\t}\n\t\tcurrentRunLength += this.size;  // Add white border to final run\n\t\tthis.finderPenaltyAddHistory(currentRunLength, runHistory);\n\t\treturn this.finderPenaltyCountPatterns(runHistory);\n\t}\n\n\t// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n\tprivate finderPenaltyAddHistory(currentRunLength: int, runHistory: Array<int>): void\n\t{\n\t\tif (runHistory[0] == 0)\n\t\t\tcurrentRunLength += this.size;  // Add white border to initial run\n\t\trunHistory.pop();\n\t\trunHistory.unshift(currentRunLength);\n\t}\n\n\t// The minimum version number supported in the QR Code Model 2 standard.\n\tpublic static readonly MIN_VERSION: int = 1;\n\t// The maximum version number supported in the QR Code Model 2 standard.\n\tpublic static readonly MAX_VERSION: int = 40;\n\n\t// For use in getPenaltyScore(), when evaluating which mask is best.\n\tprivate static readonly PENALTY_N1: int = 3;\n\tprivate static readonly PENALTY_N2: int = 3;\n\tprivate static readonly PENALTY_N3: int = 40;\n\tprivate static readonly PENALTY_N4: int = 10;\n\n\tprivate static readonly ECC_CODEWORDS_PER_BLOCK: Array<Array<int>> = [\n\t\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t\t//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t\t[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // Low\n\t\t[-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],  // Medium\n\t\t[-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // Quartile\n\t\t[-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // High\n\t];\n\n\tprivate static readonly NUM_ERROR_CORRECTION_BLOCKS: Array<Array<int>> = [\n\t\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t\t//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t\t[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],  // Low\n\t\t[-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],  // Medium\n\t\t[-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],  // Quartile\n\t\t[-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],  // High\n\t];\n\n}\n\n// Appends the given number of low-order bits of the given value\n// to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.\nfunction appendBits(val: int, len: int, bb: Array<bit>): void\n{\n\tif (len < 0 || len > 31 || val >>> len != 0)\n\t\tthrow \"Value out of range\";\n\tfor (let i = len - 1; i >= 0; i--)  // Append bit by bit\n\t\tbb.push((val >>> i) & 1);\n}\n\n\n// Returns true iff the i'th bit of x is set to 1.\nfunction getBit(x: int, i: int): boolean\n{\n\treturn ((x >>> i) & 1) != 0;\n}\n\n/*---- Data segment class ----*/\nexport class QrSegment\n{\n\t// Returns a segment representing the given binary data encoded in\n\t// byte mode. All input byte arrays are acceptable. Any text string\n\t// can be converted to UTF-8 bytes and encoded as a byte mode segment.\n\tpublic static makeBytes(data: Array<byte>): QrSegment\n\t{\n\t\tlet bb: Array<bit> = []\n\t\tfor (const b of data)\n\t\t\tappendBits(b, 8, bb);\n\t\treturn new QrSegment(Mode.BYTE, data.length, bb);\n\t}\n\n\t// Returns a segment representing the given string of decimal digits encoded in numeric mode.\n\tpublic static makeNumeric(digits: string): QrSegment\n\t{\n\t\tif (!this.NUMERIC_REGEX.test(digits))\n\t\t\tthrow \"String contains non-numeric characters\";\n\t\tlet bb: Array<bit> = []\n\t\tfor (let i = 0; i < digits.length;)\n\t\t{  // Consume up to 3 digits per iteration\n\t\t\tconst n: int = Math.min(digits.length - i, 3);\n\t\t\tappendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);\n\t\t\ti += n;\n\t\t}\n\t\treturn new QrSegment(Mode.NUMERIC, digits.length, bb);\n\t}\n\n\t// Returns a segment representing the given text string encoded in alphanumeric mode.\n\t// The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n\t// dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\tpublic static makeAlphanumeric(text: string): QrSegment\n\t{\n\t\tif (!this.ALPHANUMERIC_REGEX.test(text))\n\t\t\tthrow \"String contains unencodable characters in alphanumeric mode\";\n\t\tlet bb: Array<bit> = []\n\t\tlet i: int;\n\t\tfor (i = 0; i + 2 <= text.length; i += 2)\n\t\t{  // Process groups of 2\n\t\t\tlet temp: int = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n\t\t\ttemp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n\t\t\tappendBits(temp, 11, bb);\n\t\t}\n\t\tif (i < text.length)  // 1 character remaining\n\t\t\tappendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n\t\treturn new QrSegment(Mode.ALPHANUMERIC, text.length, bb);\n\t}\n\n\t// Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n\t// The result may use various segment modes and switch modes to optimize the length of the bit stream.\n\tpublic static makeSegments(text: string): Array<QrSegment>\n\t{\n\t\t// Select the most efficient segment encoding automatically\n\t\tif (text == \"\")\n\t\t\treturn [];\n\t\telse if (this.NUMERIC_REGEX.test(text))\n\t\t\treturn [QrSegment.makeNumeric(text)];\n\t\telse if (this.ALPHANUMERIC_REGEX.test(text))\n\t\t\treturn [QrSegment.makeAlphanumeric(text)];\n\t\telse\n\t\t\treturn [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];\n\t}\n\n\t// Returns a segment representing an Extended Channel Interpretation\n\t// (ECI) designator with the given assignment value.\n\tpublic static makeEci(assignVal: int): QrSegment\n\t{\n\t\tlet bb: Array<bit> = []\n\t\tif (assignVal < 0)\n\t\t\tthrow \"ECI assignment value out of range\";\n\t\telse if (assignVal < (1 << 7))\n\t\t\tappendBits(assignVal, 8, bb);\n\t\telse if (assignVal < (1 << 14))\n\t\t{\n\t\t\tappendBits(2, 2, bb);\n\t\t\tappendBits(assignVal, 14, bb);\n\t\t} else if (assignVal < 1000000)\n\t\t{\n\t\t\tappendBits(6, 3, bb);\n\t\t\tappendBits(assignVal, 21, bb);\n\t\t} else\n\t\t\tthrow \"ECI assignment value out of range\";\n\t\treturn new QrSegment(Mode.ECI, 0, bb);\n\t}\n\n\t// Creates a new QR Code segment with the given attributes and data.\n\t// The character count (numChars) must agree with the mode and the bit buffer length,\n\t// but the constraint isn't checked. The given bit buffer is cloned and stored.\n\tpublic constructor(\n\t\t// The mode indicator of this segment.\n\t\tpublic readonly mode: Mode,\n\n\t\t// The length of this segment's unencoded data. Measured in characters for\n\t\t// numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n\t\t// Always zero or positive. Not the same as the data's bit length.\n\t\tpublic readonly numChars: int,\n\n\t\t// The data bits of this segment. Accessed through getData().\n\t\tprivate readonly bitData: Array<bit>)\n\t{\n\n\t\tif (numChars < 0)\n\t\t\tthrow \"Invalid argument\";\n\t\tthis.bitData = bitData.slice();  // Make defensive copy\n\t}\n\n\t/*-- Methods --*/\n\n\t// Returns a new copy of the data bits of this segment.\n\tpublic getData(): Array<bit>\n\t{\n\t\treturn this.bitData.slice();  // Make defensive copy\n\t}\n\n\t// (Package-private) Calculates and returns the number of bits needed to encode the given segments at\n\t// the given version. The result is infinity if a segment has too many characters to fit its length field.\n\tpublic static getTotalBits(segs: Array<QrSegment>, version: int): number\n\t{\n\t\tlet result: number = 0;\n\t\tfor (const seg of segs)\n\t\t{\n\t\t\tconst ccbits: int = seg.mode.numCharCountBits(version);\n\t\t\tif (seg.numChars >= (1 << ccbits))\n\t\t\t\treturn Infinity;  // The segment's length doesn't fit the field's bit width\n\t\t\tresult += 4 + ccbits + seg.bitData.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\t// Returns a new array of bytes representing the given string encoded in UTF-8.\n\tprivate static toUtf8ByteArray(str: string): Array<byte>\n\t{\n\t\tstr = encodeURI(str);\n\t\tlet result: Array<byte> = [];\n\t\tfor (let i = 0; i < str.length; i++)\n\t\t{\n\t\t\tif (str.charAt(i) != \"%\")\n\t\t\t\tresult.push(str.charCodeAt(i));\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.push(parseInt(str.substr(i + 1, 2), 16));\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/*-- Constants --*/\n\n\t// Describes precisely all strings that are encodable in numeric mode. To test\n\t// whether a string s is encodable: let ok: boolean = NUMERIC_REGEX.test(s);\n\t// A string is encodable iff each character is in the range 0 to 9.\n\tpublic static readonly NUMERIC_REGEX: RegExp = /^[0-9]*$/;\n\n\t// Describes precisely all strings that are encodable in alphanumeric mode. To test\n\t// whether a string s is encodable: let ok: boolean = ALPHANUMERIC_REGEX.test(s);\n\t// A string is encodable iff each character is in the following set: 0 to 9, A to Z\n\t// (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\tpublic static readonly ALPHANUMERIC_REGEX: RegExp = /^[A-Z0-9 $%*+.\\/:-]*$/;\n\n\t// The set of all legal characters in alphanumeric mode,\n\t// where each character value maps to the index in the string.\n\tprivate static readonly ALPHANUMERIC_CHARSET: string = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n}\n\nexport class Ecc\n{\n\tpublic static readonly LOW = new Ecc(0, 1);  // The QR Code can tolerate about  7% erroneous codewords\n\tpublic static readonly MEDIUM = new Ecc(1, 0);  // The QR Code can tolerate about 15% erroneous codewords\n\tpublic static readonly QUARTILE = new Ecc(2, 3);  // The QR Code can tolerate about 25% erroneous codewords\n\tpublic static readonly HIGH = new Ecc(3, 2);  // The QR Code can tolerate about 30% erroneous codewords\n\n\tprivate constructor(\n\t\t// In the range 0 to 3 (unsigned 2-bit integer).\n\t\tpublic readonly ordinal: int,\n\t\t// (Package-private) In the range 0 to 3 (unsigned 2-bit integer).\n\t\tpublic readonly formatBits: int) { }\n\n}\n\nexport class Mode\n{\n\tpublic static readonly NUMERIC = new Mode(0x1, [10, 12, 14]);\n\tpublic static readonly ALPHANUMERIC = new Mode(0x2, [9, 11, 13]);\n\tpublic static readonly BYTE = new Mode(0x4, [8, 16, 16]);\n\tpublic static readonly KANJI = new Mode(0x8, [8, 10, 12]);\n\tpublic static readonly ECI = new Mode(0x7, [0, 0, 0]);\n\n\tprivate constructor(\n\t\t// The mode indicator bits, which is a uint4 value (range 0 to 15).\n\t\tpublic readonly modeBits: int,\n\t\t// Number of character count bits for three different version ranges.\n\t\tprivate readonly numBitsCharCount: [int, int, int]) { }\n\n\t// (Package-private) Returns the bit width of the character count field for a segment in\n\t// this mode in a QR Code at the given version number. The result is in the range [0, 16].\n\tpublic numCharCountBits(ver: int): int\n\t{\n\t\treturn this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n\t}\n}"],"names":["dataCapacityBits"],"mappings":"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"}